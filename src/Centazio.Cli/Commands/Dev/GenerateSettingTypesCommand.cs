using System.Text;
using System.Text.Json;
using System.Text.Json.Nodes;
using Centazio.Cli.Infra;
using Centazio.Core.Misc;

namespace Centazio.Cli.Commands.Dev;

public class GenerateSettingTypesCommand(ITemplater templater) : AbstractCentazioCommand<CommonSettings> {
  
  protected override Task<CommonSettings> GetInteractiveSettings() => Task.FromResult(new CommonSettings());

  protected override async Task ExecuteImpl(string name, CommonSettings cmdsetts) {
    var dir = FsUtils.GetSolutionFilePath("src", "Centazio.Core", "Settings");
    var json = await File.ReadAllTextAsync(Path.Combine(dir, "settings_schema.json"));
    var schema = JsonNode.Parse(json) ?? throw new Exception();

    var sb = new StringBuilder();
    new SettingsClassGenerator(schema.AsObject(), sb, templater).GenerateClasses();

    await File.WriteAllTextAsync(Path.Combine(dir, "SettingsTypes.cs"), sb.ToString());
  }

  public class SettingsClassGenerator(JsonObject schema, StringBuilder sb, ITemplater templater) {

    private readonly string HEADER = @"

///////////////////////////////////////////////////////////////////////////////
// Note: this file is generated by `centazio dev gen-settings` - DO NOT MODIFY
///////////////////////////////////////////////////////////////////////////////

using Centazio.Core.Misc;

namespace Centazio.Core.Settings;

"; 
   
    private readonly string RECORD_TEMPLATE = @"
public record {{ it.ClassName }} {
{{ for field in it.Fields }}
  {{ field.PropertyDefenition }}{{ end }}

  public Dto ToDto() => new() { {{ for field in it.Fields }}
    {{ field.ToDtoPropertyPair }}{{ end }}
  };

  public record Dto : IDto<{{it.ClassName}}> { {{ for field in it.Fields }}
    {{ field.DtoPropertyDefenition }}{{ end }}

    public {{ it.ClassName }} ToBase() => new() { {{ for field in it.Fields }}
      {{ field.ToBasePropertyPair }}{{ end }}
    };
  }
}";
    
    public void GenerateClasses() {
      sb.Append(HEADER);
      schema.Select(p => new FieldSpec(p, String.Empty))
          .Where(n => n.Value.GetValueKind() == JsonValueKind.Object)
          .ForEach(prop => GenerateClassAndNestedTypes(prop.SettingsName, prop.Value.AsObject().ToList(), new HashSet<string>()));
    }

    private void GenerateClassAndNestedTypes(string classnm, List<KeyValuePair<string, JsonNode?>> props, HashSet<string> generated) {
      if (!generated.Add(classnm)) return;

      var fields = props.Select(prop => new FieldSpec(prop, classnm)).ToList();
      
      fields.Where(f => f.IsObj).ForEach(nestedtype => GenerateClassAndNestedTypes(nestedtype.SettingsName, nestedtype.Value.AsObject().ToList(), generated));
      
      sb.AppendLine(templater.ParseFromContent(RECORD_TEMPLATE, new { ClassName = classnm, Fields = fields }));
    }
  }

  public class FieldSpec {
    
    public string ClassName { get; }
    public string Name { get; }
    public JsonNode Value { get; }
    
    public bool Required { get; }
    public string Type { get; }
    
    public FieldSpec(KeyValuePair<string, JsonNode?> prop, string ClassName) {
      (this.ClassName, Name, Value) = (ClassName, prop.Key, prop.Value ?? throw new Exception());
      
      var obj = Value.GetValueKind() == JsonValueKind.Object ? Value.AsObject() : null;
      Type = obj?["type"]?.GetValue<string>() ?? "string";
      Required = obj?["required"]?.GetValue<bool>() ?? true;
    }
    
    public string SettingsName => Char.ToUpper(Name[0]) + Name[1..] + "Settings";
            
    public string PropertyDefenition { get {
      var requiredmod = Required ? "required " : string.Empty;
      var opt = Required ? String.Empty : "?";
      return IsObj 
          ? $"public {requiredmod}{SettingsName}{opt} {Name} {{ get; init; }}" 
          : $"public {requiredmod}{Type}{opt} {Name} {{ get; init; }}";
    } }
    
    public string DtoPropertyDefenition => IsObj 
        ? $"public {SettingsName}.Dto? {Name} {{ get; init; }}" 
        : $"public {Type}? {Name} {{ get; init; }}";

    public string ToDtoPropertyPair { get {
      if (IsObj) return $"{Name} = {Name}.ToDto(),";
      return $"{Name} = {Name},";
    }}
    
    public string ToBasePropertyPair { get {
      if (IsObj) { return Required ? $"{Name} = {Name}?.ToBase() ?? throw new ArgumentNullException(nameof({Name}))," : $"      {Name} = {Name}?.ToBase() ?? new(),"; }
      if (Type == "string") { return Required ? $"{Name} = String.IsNullOrWhiteSpace({Name}) ? throw new ArgumentNullException(nameof({Name})) : {Name}.Trim()," : $"      {Name} = {Name}?.Trim(),"; }
      return $"{Name} = {Name} ?? {GetDefaultValue()},";
    } }

    public bool IsObj => Value.GetValueKind() == JsonValueKind.Object && !IsFieldSpec(Value.AsObject());
    
    private bool IsFieldSpec(JsonObject obj) => obj.ContainsKey("type") || obj.ContainsKey("required") || obj.ContainsKey("default");

    private string GetDefaultValue() => Type.ToLower() switch {
      "bool" => "false",
      "int" => "0",
      _ => "null"
    };

  }

}