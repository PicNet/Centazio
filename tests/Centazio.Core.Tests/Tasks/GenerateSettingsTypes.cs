using System.Text;
using System.Text.Json;
using System.Text.Json.Nodes;
using Centazio.Core.Misc;

namespace Centazio.Core.Tests.Tasks;

public class GenerateSettingsTypes {

  [Test] public async Task Generate_SettingsTypes() {
    var dir = FsUtils.GetSolutionFilePath("src", "Centazio.Core", "Settings");
    var json = await File.ReadAllTextAsync(Path.Combine(dir, "settings_schema.json"));
    var schema = JsonNode.Parse(json) ?? throw new Exception();

    var contents = new SettingsClassGenerator().GenerateClasses(schema);

    await File.WriteAllTextAsync(Path.Combine(dir, "SettingsTypes.cs"), contents);
  }

  public class SettingsClassGenerator {

    public string GenerateClasses(JsonNode json) {
      var sb = new StringBuilder(@" // Note: this file is generated by GenerateSettingsTypes.cs - DO NOT MODIFY
using Centazio.Core.Misc;

namespace Centazio.Core.Settings;

");
      foreach (var prop in json.AsObject()) {
        if (prop.Value!.GetValueKind() != JsonValueKind.Object) continue;

        var className = prop.Key + "Settings";
        GenerateClassAndNestedTypes(className, prop.Value?.AsObject(), sb, new HashSet<string>());
      }

      return sb.ToString();
    }

    private static FieldSpec ParseFieldSpec(JsonNode? node) {
      if (node is null) return new FieldSpec();

      // If it's a simple string, treat it as the type with default settings
      if (node is JsonValue value) return new FieldSpec { Type = value.GetValue<string>() };

      // Otherwise, parse the detailed specification
      var obj = node.AsObject();
      return new FieldSpec {
        Type = obj["type"]?.GetValue<string>() ?? "string",
        Required = obj["required"]?.GetValue<bool>() ?? true,
        Default = obj["default"]?.GetValue<string>()
      };
    }

    private static void GenerateClassAndNestedTypes(string className, JsonObject? properties, StringBuilder sb, HashSet<string> generatedTypes) {
      if (properties is null) return;

      if (!generatedTypes.Add(className)) return;

      // First generate any nested types
      foreach (var prop in properties) {
        var fieldSpec = ParseFieldSpec(prop.Value);
        if (prop.Value!.GetValueKind() == JsonValueKind.Object && !IsFieldSpecObject(prop.Value.AsObject())) {
          var nestedClassName = char.ToUpper(prop.Key[0]) + prop.Key[1..] + "Settings";
          GenerateClassAndNestedTypes(nestedClassName, prop.Value.AsObject(), sb, generatedTypes);
        }
      }

      // Generate main record
      sb.AppendLine($"public record {className} {{");

      // Properties
      foreach (var prop in properties)
        if (prop.Value!.GetValueKind() == JsonValueKind.Object && !IsFieldSpecObject(prop.Value.AsObject())) {
          var nestedClassName = char.ToUpper(prop.Key[0]) + prop.Key[1..] + "Settings";
          var fieldSpec = ParseFieldSpec(prop.Value);
          var requiredModifier = fieldSpec.Required ? "required " : String.Empty;
          sb.AppendLine($"  public {requiredModifier}{nestedClassName} {prop.Key} {{ get; init; }}");
        }
        else {
          var fieldSpec = ParseFieldSpec(prop.Value);
          var type = GetCSharpType(fieldSpec.Type);
          var requiredModifier = fieldSpec.Required ? "required " : String.Empty;
          sb.AppendLine($"  public {requiredModifier}{type} {prop.Key} {{ get; init; }}");
        }

      sb.AppendLine();

      // ToDto method
      sb.AppendLine("  public Dto ToDto() => new() {");
      foreach (var prop in properties)
        if (prop.Value!.GetValueKind() == JsonValueKind.Object && !IsFieldSpecObject(prop.Value.AsObject()))
          sb.AppendLine($"    {prop.Key} = {prop.Key}.ToDto(),");
        else
          sb.AppendLine($"    {prop.Key} = {prop.Key},");

      sb.AppendLine("  };");

      sb.AppendLine();

      // Generate Dto record
      sb.AppendLine($"  public record Dto : IDto<{className}> {{");

      // Dto properties
      foreach (var prop in properties)
        if (prop.Value!.GetValueKind() == JsonValueKind.Object && !IsFieldSpecObject(prop.Value.AsObject())) {
          var nestedClassName = char.ToUpper(prop.Key[0]) + prop.Key[1..] + "Settings";
          sb.AppendLine($"    public {nestedClassName}.Dto? {prop.Key} {{ get; init; }}");
        }
        else {
          var fieldSpec = ParseFieldSpec(prop.Value);
          var type = GetCSharpType(fieldSpec.Type);
          sb.AppendLine($"    public {type}? {prop.Key} {{ get; init; }}");
        }

      sb.AppendLine();

      // ToBase method
      sb.AppendLine($"    public {className} ToBase() => new() {{");
      foreach (var prop in properties)
        if (prop.Value!.GetValueKind() == JsonValueKind.Object && !IsFieldSpecObject(prop.Value.AsObject())) {
          var fieldSpec = ParseFieldSpec(prop.Value);
          if (fieldSpec.Required)
            sb.AppendLine($"      {prop.Key} = {prop.Key}?.ToBase() ?? throw new ArgumentNullException(nameof({prop.Key})),");
          else
            sb.AppendLine($"      {prop.Key} = {prop.Key}?.ToBase() ?? new(),");
        }
        else {
          var fieldSpec = ParseFieldSpec(prop.Value);

          if (fieldSpec.Type == "string") {
            if (fieldSpec.Required) {
              var nullval = string.IsNullOrWhiteSpace(fieldSpec.Default) ? $"throw new ArgumentNullException(nameof({prop.Key}))" : $"\"{fieldSpec.Default}\"";
              sb.AppendLine($"      {prop.Key} = String.IsNullOrWhiteSpace({prop.Key}) ? {nullval} : {prop.Key}.Trim(),");
            }
            else {
              var defaultValue = fieldSpec.Default is not null ? $"\"{fieldSpec.Default}\"" : "null";
              sb.AppendLine($"      {prop.Key} = {prop.Key}?.Trim() ?? {defaultValue},");
            }
          }
          else if (fieldSpec.Type == "bool") {
            var defaultValue = fieldSpec.Default?.ToLower() == "true" ? "true" : "false";
            sb.AppendLine($"      {prop.Key} = {prop.Key} ?? {defaultValue},");
          }
          else {
            var defaultValue = GetDefaultValue(prop.Key, className, fieldSpec);
            sb.AppendLine($"      {prop.Key} = {prop.Key} ?? {defaultValue},");
          }
        }

      sb.AppendLine("    };");

      // Close Dto record
      sb.AppendLine("  }");

      // Close main record
      sb.AppendLine("}");
      sb.AppendLine();
    }

    private static bool IsFieldSpecObject(JsonObject obj) => obj.ContainsKey("type") || obj.ContainsKey("required") || obj.ContainsKey("default");

    private static string GetCSharpType(string jsonType) {
      return jsonType.ToLower() switch { "string" => "string", "bool" => "bool", "int" => "int", _ => "string" };
    }

    private static string GetDefaultValue(string propName, string className, FieldSpec fieldSpec) {
      if (!string.IsNullOrEmpty(fieldSpec.Default))
        return fieldSpec.Type.ToLower() switch { "int" => fieldSpec.Default, "bool" => fieldSpec.Default.ToLower(), _ => $"\"{fieldSpec.Default}\"" };

      return fieldSpec.Type.ToLower() switch {
        "bool" => "false",
        "int" => "0",
        _ => propName.EndsWith("TableName") ?
            $"nameof({className.Replace("Settings", String.Empty)}).ToLower()" :
            propName == "SchemaName" ?
                $"nameof({className.Replace("Settings", String.Empty)}).ToLower()" :
                "null"
      };
    }

  }

  private class FieldSpec {

    public string Type { get; set; } = "string";
    public bool Required { get; set; } = true;
    public string? Default { get; set; }

  }

}