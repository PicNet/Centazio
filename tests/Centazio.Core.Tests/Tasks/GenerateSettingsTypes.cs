using System.Text;
using System.Text.Json;
using System.Text.Json.Nodes;
using Centazio.Core.Misc;

namespace Centazio.Core.Tests.Tasks;

public class GenerateSettingsTypes {

  [Test] public async Task Generate_SettingsTypes() {
    var dir = FsUtils.GetSolutionFilePath("src", "Centazio.Core", "Settings");
    var json = await File.ReadAllTextAsync(Path.Combine(dir, "settings_schema.json"));
    var schema = JsonNode.Parse(json) ?? throw new Exception();

    var contents = new SettingsClassGenerator(schema).GenerateClasses();

    await File.WriteAllTextAsync(Path.Combine(dir, "SettingsTypes.cs"), contents);
  }

  public class SettingsClassGenerator(JsonNode json) {

    private readonly JsonObject schema = json.AsObject();

    public string GenerateClasses() {
      var sb = new StringBuilder(@" // Note: this file is generated by GenerateSettingsTypes.cs - DO NOT MODIFY
using Centazio.Core.Misc;

namespace Centazio.Core.Settings;

");
      schema
          .Where(n => n.Value is not null && n.Value.GetValueKind() == JsonValueKind.Object)
          .Select(n => new KeyValuePair<string, JsonNode>(n.Key, n.Value ?? throw new Exception()))
          .ForEach(prop => GenerateClassAndNestedTypes(prop.Key + "Settings", prop.Value.AsObject(), sb, new HashSet<string>()));

      return sb.ToString();
    }

    private static FieldSpec ParseFieldSpec(JsonNode? node) {
      if (node is null) return new FieldSpec();

      var obj = node.AsObject();
      return new FieldSpec {
        Type = obj["type"]?.GetValue<string>() ?? "string",
        Required = obj["required"]?.GetValue<bool>() ?? true
      };
    }

    private static void GenerateClassAndNestedTypes(string classnm, JsonObject? props, StringBuilder sb, HashSet<string> generated) {
      if (props is null || !generated.Add(classnm)) return;

      // First generate any nested types
      foreach (var prop in props) {
        if (prop.Value!.GetValueKind() != JsonValueKind.Object || IsFieldSpecObject(prop.Value.AsObject())) continue;

        var child = char.ToUpper(prop.Key[0]) + prop.Key[1..] + "Settings";
        GenerateClassAndNestedTypes(child, prop.Value.AsObject(), sb, generated);
      }
      
      // Generate main record
      sb.AppendLine($"public record {classnm} {{");

      // Properties
      foreach (var prop in props) {
        var spec = ParseFieldSpec(prop.Value);
        var requiredmod = spec.Required ? "required " : string.Empty;
        var opt = spec.Required ? String.Empty : "?";
        if (prop.Value!.GetValueKind() == JsonValueKind.Object && !IsFieldSpecObject(prop.Value.AsObject())) {
          var child = char.ToUpper(prop.Key[0]) + prop.Key[1..] + "Settings";
          sb.AppendLine($"  public {requiredmod}{child}{opt} {prop.Key} {{ get; init; }}");
        }
        else { sb.AppendLine($"  public {requiredmod}{spec.Type}{opt} {prop.Key} {{ get; init; }}"); }
      }
      sb.AppendLine();

      // ToDto method
      sb.AppendLine("  public Dto ToDto() => new() {");
      foreach (var prop in props)
        if (prop.Value!.GetValueKind() == JsonValueKind.Object && !IsFieldSpecObject(prop.Value.AsObject())) sb.AppendLine($"    {prop.Key} = {prop.Key}.ToDto(),");
        else sb.AppendLine($"    {prop.Key} = {prop.Key},");

      sb.AppendLine("  };");
      sb.AppendLine();

      // Generate Dto record
      sb.AppendLine($"  public record Dto : IDto<{classnm}> {{");

      // Dto properties
      foreach (var prop in props)
        if (prop.Value!.GetValueKind() == JsonValueKind.Object && !IsFieldSpecObject(prop.Value.AsObject())) {
          var child = char.ToUpper(prop.Key[0]) + prop.Key[1..] + "Settings";
          sb.AppendLine($"    public {child}.Dto? {prop.Key} {{ get; init; }}");
        }
        else {
          var spec = ParseFieldSpec(prop.Value);
          sb.AppendLine($"    public {spec.Type}? {prop.Key} {{ get; init; }}");
        }

      sb.AppendLine();

      // ToBase method
      sb.AppendLine($"    public {classnm} ToBase() => new() {{");
      foreach (var prop in props)
        if (prop.Value!.GetValueKind() == JsonValueKind.Object && !IsFieldSpecObject(prop.Value.AsObject())) {
          var spec = ParseFieldSpec(prop.Value);
          if (spec.Required)
            sb.AppendLine($"      {prop.Key} = {prop.Key}?.ToBase() ?? throw new ArgumentNullException(nameof({prop.Key})),");
          else
            sb.AppendLine($"      {prop.Key} = {prop.Key}?.ToBase() ?? new(),");
        }
        else {
          var spec = ParseFieldSpec(prop.Value);

          if (spec.Type == "string") {
            if (spec.Required)
              sb.AppendLine($"      {prop.Key} = String.IsNullOrWhiteSpace({prop.Key}) ? throw new ArgumentNullException(nameof({prop.Key})) : {prop.Key}.Trim(),");
            else
              sb.AppendLine($"      {prop.Key} = {prop.Key}?.Trim(),");
          }
          else {
            sb.AppendLine($"      {prop.Key} = {prop.Key} ?? {GetDefaultValue(prop.Key, classnm, spec)},");
          }
        }

      sb.AppendLine("    };");

      // Close Dto record
      sb.AppendLine("  }");

      // Close main record
      sb.AppendLine("}");
      sb.AppendLine();
    }

    private static bool IsFieldSpecObject(JsonObject obj) => obj.ContainsKey("type") || obj.ContainsKey("required") || obj.ContainsKey("default");
    
    private static string GetDefaultValue(string propName, string className, FieldSpec fieldSpec) => fieldSpec.Type.ToLower() switch {
      "bool" => "false",
      "int" => "0",
      _ => propName.EndsWith("TableName") ?
          $"nameof({className.Replace("Settings", string.Empty)}).ToLower()" :
          propName == "SchemaName" ?
              $"nameof({className.Replace("Settings", string.Empty)}).ToLower()" :
              "null"
    };

  }

  private class FieldSpec {

    public string Type { get; init; } = "string";
    public bool Required { get; init; } = true;

  }

}