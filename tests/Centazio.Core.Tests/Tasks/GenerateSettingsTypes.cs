using System.Text;
using System.Text.Json;
using System.Text.Json.Nodes;
using Centazio.Core.Misc;

namespace Centazio.Core.Tests.Tasks;

public class GenerateSettingsTypes {

  // todo: replace with propert templates rather than this ugly string hack
  [Test] public async Task Generate_SettingsTypes() {
    var dir = FsUtils.GetSolutionFilePath("src", "Centazio.Core", "Settings");
    var json = await File.ReadAllTextAsync(Path.Combine(dir, "settings_schema.json"));
    var schema = JsonNode.Parse(json) ?? throw new Exception();

    var sb = new StringBuilder();
    new SettingsClassGenerator(schema.AsObject(), sb).GenerateClasses();

    await File.WriteAllTextAsync(Path.Combine(dir, "SettingsTypes.cs"), sb.ToString());
  }

  public class SettingsClassGenerator(JsonObject schema, StringBuilder sb) {

    private readonly string HEADER = @"

///////////////////////////////////////////////////////////////////////////////
// Note: this file is generated by `centazio dev gen-settings` - DO NOT MODIFY
///////////////////////////////////////////////////////////////////////////////

using Centazio.Core.Misc;

namespace Centazio.Core.Settings;

"; 
    
    public void GenerateClasses() {
      sb.Append(HEADER);
      schema.Select(p => new FieldSpec(p))
          .Where(n => n.Value.GetValueKind() == JsonValueKind.Object)
          .ForEach(prop => GenerateClassAndNestedTypes(prop.SettingsName, prop.Value.AsObject(), new HashSet<string>()));
    }

    private void GenerateClassAndNestedTypes(string classnm, IList<KeyValuePair<string, JsonNode?>> props, HashSet<string> generated) {
      if (!generated.Add(classnm)) return;

      var fields = props.Select(prop => new FieldSpec(prop)).ToList();
      
      // generate all nested types
      fields.Where(f => f.IsObj).ForEach(nestedtype => GenerateClassAndNestedTypes(nestedtype.SettingsName, nestedtype.Value.AsObject(), generated));
      
      // Generate main record
      sb.AppendLine($"public record {classnm} {{");

      // Properties
      fields.ForEach(spec => sb.AppendLine(spec.PropertyDefenition));
      
      sb.AppendLine();

      // ToDto method
      sb.AppendLine("  public Dto ToDto() => new() {");
      fields.ForEach(spec => sb.AppendLine(spec.ToDtoPropertyPair));

      sb.AppendLine("  };");
      sb.AppendLine();

      // Generate Dto record
      sb.AppendLine($"  public record Dto : IDto<{classnm}> {{");

      // Dto properties
      fields.ForEach(spec => sb.AppendLine(spec.DtoPropertyDefenition));

      sb.AppendLine();

      // ToBase method
      sb.AppendLine($"    public {classnm} ToBase() => new() {{");
      fields.ForEach(spec => sb.AppendLine(spec.ToBasePropertyPair(classnm)));

      sb.AppendLine("    };");

      // Close Dto record
      sb.AppendLine("  }");

      // Close main record
      sb.AppendLine("}");
      sb.AppendLine();
    }
  }

  public class FieldSpec {
    
    public string Name { get; }
    public JsonNode Value { get; }
    
    public bool Required { get; }
    public string Type { get; }
    
    public FieldSpec(KeyValuePair<string, JsonNode?> prop) {
      (Name, Value) = (prop.Key, prop.Value ?? throw new Exception());
      
      var obj = Value.GetValueKind() == JsonValueKind.Object ? Value.AsObject() : null;
      Type = obj?["type"]?.GetValue<string>() ?? "string";
      Required = obj?["required"]?.GetValue<bool>() ?? true;
    }
    
    public string SettingsName => Char.ToUpper(Name[0]) + Name[1..] + "Settings";
            
    public string PropertyDefenition { get {
      var requiredmod = Required ? "required " : string.Empty;
        var opt = Required ? String.Empty : "?";
        if (IsObj) {
          return $"  public {requiredmod}{SettingsName}{opt} {Name} {{ get; init; }}";
        }
        return $"  public {requiredmod}{Type}{opt} {Name} {{ get; init; }}";
    } }
    
    public string DtoPropertyDefenition => IsObj 
        ? $"    public {SettingsName}.Dto? {Name} {{ get; init; }}" 
        : $"    public {Type}? {Name} {{ get; init; }}";

    public string ToDtoPropertyPair { get {
      if (IsObj) return $"    {Name} = {Name}.ToDto(),";
      return $"    {Name} = {Name},";
    }}
    
    public string ToBasePropertyPair(string classnm) {
      if (IsObj) { return Required ? $"      {Name} = {Name}?.ToBase() ?? throw new ArgumentNullException(nameof({Name}))," : $"      {Name} = {Name}?.ToBase() ?? new(),"; }
      if (Type == "string") { return Required ? $"      {Name} = String.IsNullOrWhiteSpace({Name}) ? throw new ArgumentNullException(nameof({Name})) : {Name}.Trim()," : $"      {Name} = {Name}?.Trim(),"; }
      return $"      {Name} = {Name} ?? {GetDefaultValue(classnm)},";
    }

    public bool IsObj => Value.GetValueKind() == JsonValueKind.Object && !IsFieldSpecObject(Value.AsObject());
    
    public bool IsFieldSpecObject(JsonObject obj) => obj.ContainsKey("type") || obj.ContainsKey("required") || obj.ContainsKey("default");

    // todo: what is all this `Name.EndsWith("TableName")` and `Name == "SchemaName"`
    private string GetDefaultValue(string className) => Type.ToLower() switch {
      "bool" => "false",
      "int" => "0",
      _ => Name.EndsWith("TableName") ?
          $"nameof({className.Replace("Settings", string.Empty)}).ToLower()" :
          Name == "SchemaName" ?
              $"nameof({className.Replace("Settings", string.Empty)}).ToLower()" :
              "null"
    };

  }

}